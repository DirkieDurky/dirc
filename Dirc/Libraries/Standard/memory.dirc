void* malloc(int size)
{
    // Force minimum size of 3 so the metadata can fit when it gets freed again.
    if (size < 3)
    {
        size = 3;
    }

    int allocatedHeaderSize = 2;
    int* freeListHeadAddress = FREE_LIST_HEAD_ADDRESS;

    if (*freeListHeadAddress == -1)
    {
        throwError("Out of memory");
    }

    int* currentBlock = *freeListHeadAddress;
    int currentBlockSize = *(currentBlock + 1);
    bool wasFirstInFreeList = true;

    while (currentBlockSize < size)
    {
        int* nextFreeBlock = currentBlock + allocatedHeaderSize;
        if (*nextFreeBlock == -1)
        {
            throwError("Not enough memory");
        }
        currentBlock = *nextFreeBlock;
        currentBlockSize = *(currentBlock + 1);
        wasFirstInFreeList = false;
    }

    allocate(currentBlock, size, wasFirstInFreeList);

    int* payloadAddress = currentBlock + 2;
    return payloadAddress;
}

void allocate(int* address, int size, bool wasFirstInFreeList)
{
    int allocatedHeaderSize = 2;
    int* freeListHeadAddress = FREE_LIST_HEAD_ADDRESS;

    int originalSize = *(address + 1);
    int nextFreeBlock = *(address + 2);
    int previousFreeBlock = *(address + 3);

    int newNextFreeBlock = nextFreeBlock;

    *address = 1; // Set in use
    *(address + 1) = size; // Set size

    // If the block is big enough, split it so we only use what we need to
    // Ensure we have 5 extra space. This is the minimum size of a free block:
    // That would look like {IsInUse, Size, NextFreeBlock, PreviousFreeBlock, Footer}
    if (originalSize >= size + 5)
    {
        int* newFreeBlock = address + allocatedHeaderSize + size;
        int newFreeBlockSize = originalSize - size - allocatedHeaderSize;
        *(newFreeBlock) = 0; // IsInUse
        *(newFreeBlock + 1) = newFreeBlockSize; // Size
        *(newFreeBlock + 2) = nextFreeBlock;
        *(newFreeBlock + 3) = previousFreeBlock;
        *(newFreeBlock + 1 + newFreeBlockSize) = newFreeBlockSize;

        if (wasFirstInFreeList)
        {
            newNextFreeBlock = newFreeBlock;
        }
    }
    
    // Update nextFreeBlock of previous block
    if (previousFreeBlock != -1)
    {
        *(previousFreeBlock + 3) = newNextFreeBlock;
    }
    else
    {
        *freeListHeadAddress = newNextFreeBlock;
    }

    // Update previousFreeBlock of next block
    if (nextFreeBlock != -1)
    {
        *(nextFreeBlock + 2) = previousFreeBlock;
    }
}

void free(void* ptr)
{
    int* freeListHeadAddress = FREE_LIST_HEAD_ADDRESS;
    int allocatedHeaderSize = 2;

    int* myHeader = ptr - allocatedHeaderSize;
    int mySize = *(myHeader + 1);

    int newSize = mySize;
    int* newHeaderAddress = myHeader;

    // Check merge with previous block
    if (myHeader > HEAP_START)
    {
        int previousBlockSize = *(ptr - 3);
        int* previousBlock = *(ptr - 3 - previousBlockSize - 1);
        bool previousBlockFree = *previousBlock;

        if (previousBlockFree)
        {
            newSize += previousBlockSize + allocatedHeaderSize;
            newHeaderAddress = previousBlock;

            // We don't have to update anything to delete previousBlock from freeList
            // because the address of the new block is the same as the previous block
        }
    }

    // Check merge with next block
    int* nextBlock = ptr + mySize;
    //if (nextBlock < HEAP_END & !*nextBlock) // '!' isn't implemented yet in the language. When it is, below line can be replaced by this one
    if (nextBlock < HEAP_END & *nextBlock == false)
    {
        int nextBlockSize = *(nextBlock + 1);
        newSize += nextBlockSize + allocatedHeaderSize;
        int* nextBlocksNextBlock = *(nextBlock + 2);
        int* nextBlocksPreviousBlock = *(nextBlock + 3);

        // Remove nextBlock from freeList (Update all values that used to point to nextBlock to point to the new merged block):
        // Update nextBlock's previousBlock's nextBlock
        if (nextBlocksPreviousBlock != -1)
        {
            *(nextBlocksPreviousBlock + 2) = newHeaderAddress;
        }
        else
        {
            *freeListHeadAddress = nextBlocksNextBlock;
        }
        // Update nextBlock's nextBlock's previousBlock
        *(nextBlocksNextBlock + 3) = newHeaderAddress;
    }

    // Free myself
    *newHeaderAddress = 0;
    *(newHeaderAddress + 1) = newSize;
    *(newHeaderAddress + 2) = *freeListHeadAddress;
    *(newHeaderAddress + 3) = -1;
    *(newHeaderAddress + 3 + newSize) = newSize;

    *freeListHeadAddress = newHeaderAddress;
}

int getSize(void* ptr)
{
    return *(ptr - 1);
}

void* realloc(void* ptr, int newSize)
{
    free(ptr);
    void* newPtr = malloc(newSize);
    if (newPtr != ptr)
    {
        for (int i = 0; i < min(getSize(ptr), newSize); i++)
        {
            newPtr[i] = ptr[i];
        }
    }

    return newPtr;
}
